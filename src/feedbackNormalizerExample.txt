/**
 * Adaptadores para normalizar los diferentes formatos de feedback
 * para su visualización en el componente FeedbackSummary.
 */

// Tipos comunes para diferentes formatos de feedback
export interface NormalizedComment {
  id: string;          // Identificador único (URL de imagen, ID de paleta, etc.)
  comment: string;     // Texto del comentario
  timestamp?: string;  // Fecha y hora en que se realizó (ISO string)
}

export interface NormalizedReaction {
  id: string;               // Identificador único del item
  type: 'positive' | 'negative' | 'comment'; // Tipo de reacción
  timestamp?: string;       // Fecha y hora en que se realizó (ISO string)
}

export interface NormalizedFeedback {
  reactions: NormalizedReaction[];  // Todas las reacciones
  comments: NormalizedComment[];    // Todos los comentarios
}

/**
 * Normaliza el feedback de una galería de imágenes
 */
export function normalizeImageGalleryFeedback(
  sectionFeedback: Record<string, unknown>
): NormalizedFeedback {
  const imageFeedback = sectionFeedback.imageFeedback as Record<string, string> || {};
  const result: NormalizedFeedback = {
    reactions: [],
    comments: []
  };
  
  // Procesar reacciones (formato: { imageUrl: reactionType })
  Object.entries(imageFeedback).forEach(([imageUrl, reactionType]) => {
    result.reactions.push({
      id: imageUrl,
      type: reactionType as 'positive' | 'negative' | 'comment'
    });
  });
  
  // Procesar comentarios en formato de array
  const comments = sectionFeedback.comments as Array<{
    imageUrl: string;
    comment: string;
    timestamp?: string;
  }> | undefined;
  
  if (comments && Array.isArray(comments)) {
    comments.forEach(comment => {
      result.comments.push({
        id: comment.imageUrl,
        comment: comment.comment,
        timestamp: comment.timestamp
      });
    });
  }
  
  // Procesar comentario en formato antiguo (objeto único)
  const singleComment = sectionFeedback.commentContent as {
    imageUrl: string;
    comment: string;
    timestamp?: string;
  } | undefined;
  
  if (singleComment && singleComment.imageUrl && singleComment.comment) {
    // Verificar si este comentario ya está incluido
    const isDuplicate = result.comments.some(
      c => c.id === singleComment.imageUrl && c.comment === singleComment.comment
    );
    
    if (!isDuplicate) {
      result.comments.push({
        id: singleComment.imageUrl,
        comment: singleComment.comment,
        timestamp: singleComment.timestamp
      });
    }
  }
  
  return result;
}

/**
 * Normaliza el feedback de una paleta de colores
 */
export function normalizePaletteFeedback(
  sectionFeedback: Record<string, unknown>
): NormalizedFeedback {
  const result: NormalizedFeedback = {
    reactions: [],
    comments: []
  };
  
  // Procesar múltiples feedbacks (formato más nuevo)
  const paletteFeedbacks = sectionFeedback.paletteFeedbacks as Array<{
    paletteId: string;
    type: string;
    timestamp: string;
  }> | undefined;
  
  if (paletteFeedbacks && Array.isArray(paletteFeedbacks)) {
    paletteFeedbacks.forEach(feedback => {
      result.reactions.push({
        id: feedback.paletteId,
        type: feedback.type as 'positive' | 'negative' | 'comment',
        timestamp: feedback.timestamp
      });
    });
  } 
  // Si no hay array de feedbacks, intentar con el feedback único
  else {
    const paletteFeedback = sectionFeedback.paletteFeedback as {
      paletteId: string;
      type: string;
      timestamp: string;
    } | undefined;
    
    if (paletteFeedback) {
      result.reactions.push({
        id: paletteFeedback.paletteId,
        type: paletteFeedback.type as 'positive' | 'negative' | 'comment',
        timestamp: paletteFeedback.timestamp
      });
    }
  }
  
  // Procesar comentarios en formato de array
  const paletteComments = sectionFeedback.paletteComments as Array<{
    paletteId: string;
    comment: string;
    timestamp?: string;
  }> | undefined;
  
  if (paletteComments && Array.isArray(paletteComments)) {
    paletteComments.forEach(comment => {
      result.comments.push({
        id: comment.paletteId,
        comment: comment.comment,
        timestamp: comment.timestamp
      });
    });
  }
  
  // Procesar comentario en formato de objeto único
  const paletteComment = sectionFeedback.paletteComment as {
    paletteId: string;
    comment: string;
    timestamp?: string;
  } | undefined;
  
  if (paletteComment && paletteComment.comment) {
    // Verificar si este comentario ya está incluido
    const isDuplicate = result.comments.some(
      c => c.id === paletteComment.paletteId && c.comment === paletteComment.comment
    );
    
    if (!isDuplicate) {
      result.comments.push({
        id: paletteComment.paletteId,
        comment: paletteComment.comment,
        timestamp: paletteComment.timestamp
      });
    }
  }
  
  return result;
}

/**
 * Normaliza el feedback de tipografía
 */
export function normalizeTypographyFeedback(
  sectionFeedback: Record<string, unknown>
): NormalizedFeedback {
  const result: NormalizedFeedback = {
    reactions: [],
    comments: []
  };
  
  // En tipografía solo hay selección y comentario simple
  const selectedFont = sectionFeedback.selectedFont as string | null;
  const fontComment = sectionFeedback.comment as string | null;
  
  if (selectedFont) {
    result.reactions.push({
      id: selectedFont,
      type: 'positive'  // La selección de fuente se considera feedback positivo
    });
  }
  
  if (fontComment) {
    result.comments.push({
      id: 'typography',  // ID genérico para comentarios de tipografía
      comment: fontComment
    });
  }
  
  return result;
}

/**
 * Normaliza el feedback de secciones de texto
 */
export function normalizeTextFeedback(
  sectionFeedback: Record<string, unknown>
): NormalizedFeedback {
  const result: NormalizedFeedback = {
    reactions: [],
    comments: []
  };
  
  const textReaction = sectionFeedback.reaction as string | null;
  const textComment = sectionFeedback.comment as string | null;
  
  if (textReaction) {
    result.reactions.push({
      id: 'text',  // ID genérico para reacciones de texto
      type: textReaction as 'positive' | 'negative' | 'comment'
    });
  }
  
  if (textComment) {
    result.comments.push({
      id: 'text',  // ID genérico para comentarios de texto
      comment: textComment
    });
  }
  
  return result;
}

/**
 * Normaliza el feedback de enlaces
 */
export function normalizeLinksFeedback(
  sectionFeedback: Record<string, unknown>
): NormalizedFeedback {
  const result: NormalizedFeedback = {
    reactions: [],
    comments: []
  };
  
  // Procesar reacciones a enlaces
  const linkFeedback = sectionFeedback.linkFeedback as Record<string, string> | undefined;
  if (linkFeedback) {
    Object.entries(linkFeedback).forEach(([linkId, reactionType]) => {
      result.reactions.push({
        id: linkId,
        type: reactionType as 'positive' | 'negative' | 'comment'
      });
    });
  }
  
  // Procesar comentarios de enlaces
  const linkComments = sectionFeedback.linkComments as Record<string, string> | undefined;
  if (linkComments) {
    Object.entries(linkComments).forEach(([linkId, comment]) => {
      result.comments.push({
        id: linkId,
        comment
      });
    });
  }
  
  return result;
}

/**
 * Normaliza el feedback basado en el tipo de sección
 */
export function normalizeFeedback(
  sectionType: string,
  sectionFeedback: Record<string, unknown>
): NormalizedFeedback {
  switch (sectionType) {
    case 'imageGallery':
      return normalizeImageGalleryFeedback(sectionFeedback);
    case 'palette':
      return normalizePaletteFeedback(sectionFeedback);
    case 'typography':
      return normalizeTypographyFeedback(sectionFeedback);
    case 'text':
      return normalizeTextFeedback(sectionFeedback);
    case 'links':
      return normalizeLinksFeedback(sectionFeedback);
    default:
      return { reactions: [], comments: [] };
  }
}
